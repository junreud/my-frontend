아래 예시는 **“여러 개의 알림(Toast)을 동시에 관리”** 하고,  
1) **새 알림이 들어오면 기존 알림 뒤로(위로) 쌓이는** 스택 구조,  
2) **일정 시간 후 자동으로 사라짐** (fade-out 애니메이션),  
3) **알림이 사라지면 그 자리가 자연스럽게 줄어듦** (애니메이션)  
을 구현한 전형적인 Toast 시스템 예시입니다.

원리는 크게 두 부분으로 나뉩니다:

1. **ToastProvider/ToastContext**: 전역적으로 관리할 알림 배열과, 알림을 추가(`addToast`)하고 제거(`removeToast`)하는 로직을 담은 **Context**.  
2. **ToastContainer & Toast 컴포넌트**: 실제로 화면 하단/우측 등에 토스트 목록을 렌더링하며, 각 토스트는 자동으로 사라지는 타이머 + (등장/퇴장) 애니메이션을 갖습니다.

> #### 사용 방법 개요
> - **_Root_** 컴포넌트(예: `layout.tsx`)에서 `<ToastProvider>`로 감싸 주세요.  
> - 원하는 곳에서 `import { useToast } from '@/context/ToastContext';` 후, `useToast().addToast(...)` 를 호출하면 알림이 쌓입니다.

---

## 1) ToastContext.tsx (ToastProvider)

아래 코드를 `context/ToastContext.tsx` 같은 곳에 만들어 두세요.

```tsx
"use client";

import React, { createContext, useContext, useState, ReactNode } from "react";
import { v4 as uuidv4 } from "uuid";
import ToastContainer from "./ToastContainer";

/** 알림 유형(아이콘/색 구분에 사용) */
export type ToastType = "success" | "error" | "warning" | "info";

export interface ToastMessage {
  id: string;             // 고유 ID
  type: ToastType;        // 알림 유형
  title: string;          // 제목
  description?: string;   // 본문 (선택)
}

/** Context에 담길 함수/값들 */
interface ToastContextValue {
  /** 새 Toast 추가 */
  addToast: (toast: Omit<ToastMessage, "id">) => void;
}

/** 실제 Context 생성 */
const ToastContext = createContext<ToastContextValue | null>(null);

/** ToastContext를 사용하기 위한 헬퍼 훅 */
export function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
}

/** Provider: 알림(Toast)들을 전역으로 관리할 영역 */
export function ToastProvider({ children }: { children: ReactNode }) {
  const [toasts, setToasts] = useState<ToastMessage[]>([]);

  /** 새 Toast 추가: 맨 아래(또는 맨 위)에 쌓이게 하려면 배열 조작 */
  const addToast = (toast: Omit<ToastMessage, "id">) => {
    const id = uuidv4(); // 고유 ID 생성
    setToasts((prev) => [...prev, { id, ...toast }]);
    // ↑ 위 코드: 새 토스트를 "마지막"에 추가 (아래→위). 
    //   만약 "맨 위"로 쌓고 싶다면 unshift를 이용하면 됩니다.
  };

  /** 특정 토스트 제거 */
  const removeToast = (id: string) => {
    setToasts((prev) => prev.filter((t) => t.id !== id));
  };

  return (
    <ToastContext.Provider value={{ addToast }}>
      {children}
      {/** 실제 Toast들을 화면에 렌더링하는 컨테이너 */}
      <ToastContainer toasts={toasts} removeToast={removeToast} />
    </ToastContext.Provider>
  );
}
```

> - `ToastProvider` 안에는 `toasts` 라는 배열(state)이 있고, `addToast(...)` 를 통해 새 알림을 쌓습니다.  
> - `ToastContainer` 라는 컴포넌트를 하나 렌더링해서, `toasts` 배열을 순회하며 `<Toast>` 여러 개를 보여줍니다.

---

## 2) ToastContainer.tsx (알림 묶음 컨테이너)

`ToastContainer`는 **하단/우측**에 “N개의 Toast”를 쌓아 올려주는 래퍼입니다.  

```tsx
"use client";

import React from "react";
import { ToastMessage } from "./ToastContext";
import Toast from "./Toast";

interface ToastContainerProps {
  toasts: ToastMessage[];
  removeToast: (id: string) => void;
}

/**
 * 여러 개의 Toast를 화면 하단/우측에 쌓아 보여주는 컨테이너
 */
export default function ToastContainer({
  toasts,
  removeToast,
}: ToastContainerProps) {
  return (
    <div
      className="
        pointer-events-none
        fixed bottom-0 right-0
        flex 
        flex-col 
        items-end 
        p-4
        space-y-2 
        sm:space-y-3
      "
    >
      {toasts.map((toast) => (
        <Toast key={toast.id} toast={toast} onRemove={removeToast} />
      ))}
    </div>
  );
}
```

> - `fixed bottom-0 right-0 flex flex-col items-end` 로 우측 하단에 쌓이도록 했습니다.  
> - `space-y-2` 로 토스트들이 수직 간격을 유지합니다. (새 알람이 들어오면 아래쪽에 붙고, 그 위로 기존 알림들이 밀려 올라가는 형태)

---

## 3) Toast.tsx (개별 알림 컴포넌트)

각 개별 Toast는:  
- **등장 시** fade-in/slide-up  
- **일정 시간(예: 3초) 이후** 자동 fade-out  
- fade-out이 완료된 뒤 **배열에서 제거** (DOM에서 사라짐)  

```tsx
"use client";

import React, { useEffect, useState } from "react";
import { ToastMessage } from "./ToastContext";
import clsx from "clsx";

interface ToastProps {
  toast: ToastMessage;
  onRemove: (id: string) => void;
}

/**
 * 개별 알림 컴포넌트
 * - 자동 닫힘 타이머
 * - fade-in / fade-out 애니메이션
 * - type별 아이콘/색상
 */
export default function Toast({ toast, onRemove }: ToastProps) {
  const { id, type, title, description } = toast;
  const [visible, setVisible] = useState<boolean>(true);

  // (1) "등장 후 3초"가 지나면 사라지기 시작
  useEffect(() => {
    const timer = setTimeout(() => {
      setVisible(false);
    }, 3000); // 3초
    return () => clearTimeout(timer);
  }, []);

  // (2) fade-out 애니메이션 끝나면 실제로 remove
  useEffect(() => {
    if (!visible) {
      // 애니메이션 시간을 약간 기다렸다가 remove
      const timer = setTimeout(() => {
        onRemove(id);
      }, 300); // Tailwind duration-300 에 맞춤
      return () => clearTimeout(timer);
    }
  }, [visible, id, onRemove]);

  // (3) type별 아이콘/색상 설정
  const typeConfig: Record<
    typeof type,
    { iconPath: string; colorClass: string }
  > = {
    success: {
      iconPath:
        "M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z",
      colorClass: "text-green-400",
    },
    error: {
      iconPath: "M10 9v2m0 4h.01m9-2a9 9 0 11-18 0 9 9 0 0118 0z",
      colorClass: "text-red-400",
    },
    warning: {
      iconPath:
        "M9.401 13.277a.75.75 0 101.198.89l-.058-.078-.058-.075.058.075...",
      colorClass: "text-yellow-400",
    },
    info: {
      iconPath:
        "M11.25 9.75h.008v.008h-.008V9.75zm0 3.75h.008v3.75h-.008v-3.75zM21 ...",
      colorClass: "text-blue-400",
    },
  };

  const { iconPath, colorClass } = typeConfig[type];

  // (4) Tailwind 애니메이션 클래스
  // fade-in: opacity-0 -> opacity-100, translate-y-2 -> translate-y-0
  // fade-out: 반대
  // visible 값에 따라 삼항연산자로 클래스 토글
  const containerClass = clsx(
    "transform transition-all duration-300",
    visible
      ? "opacity-100 translate-y-0"
      : "opacity-0 translate-y-2 pointer-events-none"
  );

  return (
    <div className={containerClass}>
      <div
        className="
          pointer-events-auto 
          w-72 
          max-w-sm 
          overflow-hidden 
          rounded-lg 
          bg-white 
          shadow-lg 
          ring-1 
          ring-black 
          ring-opacity-5
        "
      >
        <div className="p-4 flex">
          <div className="flex-shrink-0">
            <svg
              className={`h-6 w-6 ${colorClass}`}
              fill="none"
              viewBox="0 0 24 24"
              strokeWidth={1.5}
              stroke="currentColor"
              aria-hidden="true"
            >
              <path strokeLinecap="round" strokeLinejoin="round" d={iconPath} />
            </svg>
          </div>
          <div className="ml-3 flex-1">
            <p className="text-sm font-medium text-gray-900">{title}</p>
            {description && (
              <p className="mt-1 text-sm text-gray-500">{description}</p>
            )}
          </div>
          {/* 수동으로 닫기 버튼(원하면 생략 가능) */}
          <button
            onClick={() => setVisible(false)}
            className="ml-4 flex-shrink-0 text-gray-400 hover:text-gray-500"
          >
            <span className="sr-only">Close</span>
            <svg
              className="h-5 w-5"
              viewBox="0 0 20 20"
              fill="currentColor"
              aria-hidden="true"
            >
              <path
                d="M6.28 5.22a.75.75 0 00-1.06 
                  1.06L8.94 10l-3.72 3.72a.75.75 
                  0 101.06 1.06L10 11.06l3.72 
                  3.72a.75.75 0 101.06-1.06L11.06 
                  10l3.72-3.72a.75.75 
                  0 00-1.06-1.06L10 8.94 6.28 5.22z"
              />
            </svg>
          </button>
        </div>
      </div>
    </div>
  );
}
```

> - `visible`이 `true`일 때 → `opacity-100 translate-y-0`  
> - `false`일 때 → `opacity-0 translate-y-2`  
>   - 그 후 0.3초 뒤(`setTimeout(…,300)`) 실제로 `removeToast`해서 배열에서 제거 → DOM에서 사라짐  
> - **자동 타이머**로 3초 뒤에 fade-out을 시작하게끔 했고, 닫기 버튼도 넣어서 수동으로 끌 수도 있게 했습니다.

---

## 4) 루트에서 Provider 등록

Next.js 13 기준, 보통 `app/layout.tsx` (또는 `app/(somegroup)/layout.tsx`) 파일이 전체를 감싸는 레이아웃입니다.  
아래처럼 `<ToastProvider>`로 감싸 두면, **모든 자식 컴포넌트**에서 `useToast()`로 알림을 띄울 수 있게 됩니다.

```tsx
// app/layout.tsx
import "./globals.css";
import { Inter } from "next/font/google";
import { ToastProvider } from "@/context/ToastContext";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Next App",
  description: "My App",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        {/* ToastProvider로 전체를 감쌈 */}
        <ToastProvider>
          {children}
        </ToastProvider>
      </body>
    </html>
  );
}
```

---

## 5) 실제 사용 예시

예: 로그인 페이지에서 오류가 나면 **“error”** 알림, 성공 시 **“success”** 알림을 띄운다고 합시다.

```tsx
// app/login/page.tsx
"use client";

import React, { useState } from "react";
import { useRouter } from "next/navigation";
import { useToast } from "@/context/ToastContext";
import apiClient from "@/lib/apiClient";
// 이미 작성된 컴포넌트
import LogInHeader from "@/components/LogInPage/LogInHeader";
import LogInBox from "@/components/LogInPage/LogInBox";

export default function LoginPage() {
  const router = useRouter();
  const { addToast } = useToast(); // 토스트 추가 함수

  const [loading, setLoading] = useState(false);

  // 로그인 버튼 누르면 실행
  const handleLocalLogin = async (email: string, password: string) => {
    setLoading(true);
    try {
      const res = await apiClient.post("/auth/login", { email, password });
      const { accessToken } = res.data;
      localStorage.setItem("accessToken", accessToken);

      // 성공 알림
      addToast({
        type: "success",
        title: "로그인 성공",
        description: "대시보드로 이동합니다.",
      });

      setTimeout(() => {
        router.push("/dashboard");
      }, 500); // 반응 볼 시간 주고 이동
    } catch (err) {
      console.error("로그인 실패:", err);

      // 실패 알림
      addToast({
        type: "error",
        title: "로그인 실패",
        description: "아이디/비번을 확인해주세요.",
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="bg-white min-h-screen flex flex-col">
      <LogInHeader />
      <main>
        {loading ? (
          <div className="flex items-center justify-center min-h-screen">
            <div className="animate-spin rounded-full h-16 w-16 border-4 border-gray-300 border-t-transparent" />
          </div>
        ) : (
          <LogInBox onLogin={handleLocalLogin} />
        )}
      </main>
    </div>
  );
}
```

이제 `handleLocalLogin` 에서 `addToast({ type, title, description })` 호출 시 해당 메시지가 **우측 하단**에 스르륵 뜨고, 3초 뒤 스르륵 사라집니다. 알림이 여러 번 연속 들어오면 아래쪽(최신)에 새 알림이 쌓이고, 이전 알림은 위로 밀려 올라갑니다.

---

# 정리

1. **ToastProvider**로 전체 앱을 감싸 전역적으로 알림 배열을 관리.  
2. **useToast()**를 통해 어디서든 `addToast({type, title, description})` 호출 → 새 알림이 자동 등장/퇴장.  
3. **ToastContainer**가 toasts 배열을 순회해 **하단에** `<Toast>`들을 **겹쳐 쌓아** 렌더링.  
4. 각 Toast는 3초 후 자동 fade-out 애니메이션 후 제거.

이를 통해  
- **자동으로 사라지는** 애니메이션,  
- **새 알림이 오면 기존 알림은 위로 밀리는** 스택 구조,  
- **사라지면(퇴장) 자연스럽게 공간이 줄어드는** 효과  
모두 구현할 수 있습니다. Tailwind의 `transition-all duration-300` 등을 적절히 조정하면 애니메이션을 더욱 부드럽게 만들 수 있습니다. 필요에 따라 **Framer Motion**이나 **React Transition Group** 같은 라이브러리를 쓰면 더 정교한 애니메이션도 구현 가능합니다.  